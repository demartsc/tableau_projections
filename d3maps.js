// this code was adapted from an original piece of code provided by Tamas Foldi. 
var CANVAS_SELECTOR, TABLEAU_NULL, convertRowToObject, drawLinks, drawNodes, drawNodesAndLinks, drawSanKeyGraph, errorWrapped, getColumnIndexes, getCurrentViz, getCurrentWorksheet, getTableau, initEditor, makeSanKeyData,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };


TABLEAU_NULL = '%null%';

//document.domain = 'brilliant-data.net';

getTableau = function() {
  return parent.parent.tableau;
};

getCurrentViz = function() {
  return getTableau().VizManager.getVizs()[0];
};

getCurrentWorkbook = function() {
  return getCurrentViz().getWorkbook();
};

getCurrentWorksheet = function() {
  return getCurrentViz().getWorkbook().getActiveSheet().getWorksheets()[0];
};

getCurrentWorksheets = function() {
  return getCurrentViz().getWorkbook().getActiveSheet().getWorksheets();
};

errorWrapped = function(context, fn) {
  return function() {
    var args, err, error;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    try {
      return fn.apply(null, args);
    } catch (error) {
      err = error;
      return console.error("Got error during '", context, "' : ", err.message, err.stack);
    }
  };
};

// ---
// generated by coffee-script 1.9.2
getColumnIndexes = function(table, required_keys) {
  var c, colIdxMaps, fn, j, len, ref;
  colIdxMaps = {};
  ref = table.getColumns();
  for (j = 0, len = ref.length; j < len; j++) {
    c = ref[j];
    fn = c.getFieldName();
    if (indexOf.call(required_keys, fn) >= 0) {
      colIdxMaps[fn] = c.getIndex();
    }
  }
  return colIdxMaps;
};

//converts 
convertRowToObject = function(row, attrs_map) {
  var id, name, o;
  o = {};
  for (name in attrs_map) {
    id = attrs_map[name];
    o[name] = row[id].value;
  }
  return o;
};

//this function is the start of it all and calls/references the above functions
initEditor = function() {
  var onDataLoadError, onDataLoadOk, tableau, updateEditor;
  tableau = getTableau();

  onDataLoadError = function(err) {
    return console.error("Error during Tableau Async request:", err._error.message, err._error.stack);
  };
  onDataLoadOk = errorWrapped("Getting data from Tableau", function(table) {
    var col_indexes, data, row, tableauData;
    //we have hardcoded column indexes here, but there is probably a better way
    col_indexes = getColumnIndexes(table, ["Alpha3", "Country","Country Code", "Name", "Region", "Year", "Birth Rate", "CO2 Emissions", "GDP", "Infant Mortality Rate", "Internet Usage", "Life Expectancy Female", "Life Expectancy Male", "Population Total"]);
    //console.log(col_indexes);
    data = (function() {
      var j, len, ref, results;
      ref = table.getData();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        results.push(convertRowToObject(row, col_indexes));
      }
      return results;
    })();
    console.log(data);
    tableauData = data; 
    $('#htext').val(JSON.stringify(tableauData)); // trying to save this to a hidden object for later use
    drawMap(tableauData); // set up base graph with all data
  });

  //this is not getting triggered anymore, moved it outside below
  function updateEditor(urlArray) {

    //console.log("Testing whether this triggers for " + urlArray[0]);
    return getCurrentWorksheet().getUnderlyingDataAsync({
      maxRows: 0,
      ignoreSelection: true,
      includeAllColumns: true,
      ignoreAliases: true
    }).then(onDataLoadOk, onDataLoadError);

  };

  function onParmChange(parmEvent) {
    //check on what we are receiving in this function
    //parms = getCurrentWorkbook().getParametersAsync(); //get parms, having trouble getting to them from event

    console.log("we are in the parmChange", parmEvent.getParameterName());
    console.log(parmEvent.getParameterAsync());

    //if (parmEvent.getParameterName() == parms.getName()) {
    if (parmEvent.getParameterName() == 'Color By') {
      //console.log(parmEvent.getParameterAsync().getCurrentValue());      
      //updateColor(parms.getCurrentValue());
      updateColor('GDP'); //hardcoding to test the subsequent function call
    }
    else if (parmEvent.getParameterName() == 'Projections') {
      //console.log(parmEvent.getParameterAsync().getCurrentValue());      
      //updateProjection(parms.getCurrentValue());
      updateProjection('Robinson'); //hardcoding to test the subsequent function call
    }
    //}
  }
 
  function GetSelectedParm(Parameter) {
    // not sure we need this at this point
    conole.log('here');
  }

  GetSelectedParmError = function(err) {
    // not sure we need this at this point
    return console.error("Error during Tableau marks request:", err.message, err.stack);
  };


  function getColor(valueIn, valuesIn) {

    var color = d3.scale.linear() // create a linear scale
      .domain([valuesIn[0],valuesIn[1]])  // input uses min and max values
      .range([.3,1]);   // output for opacity between .3 and 1 %

    return color(valueIn);  // return that number to the caller
  }
  
  function updateColor(parmValue) {
    // obtained from http://bl.ocks.org/rgdonohue/9280446 and modified slightly
    // not sure we need this at this point
    console.log('setting color to be based on:', parmValue);

    var dataRange = getDataRange(parmValue); // get the min/max values from the current year's range of data values
    d3.selectAll('.country').transition()  //select all the countries and prepare for a transition to new values
      .duration(1500)  // give it a smooth time period for the transition
      .attr('fill-opacity', function(d) {
        return getColor(d[parmValue], dataRange);  // the end color value
      })

    //d3.selectAll(".country").style("fill",function(d) { return color(d.id); });

  }

  function getDataRange(parmValue) {
    // obtained from http://bl.ocks.org/rgdonohue/9280446
    // function loops through all the data values from the current data attribute
    // and returns the min and max values

    var min = Infinity, max = -Infinity;  
    d3.selectAll('.country')
      .each(function(d,i) {
        var currentValue = parseFloat(d[parmValue]); //d.attr(parmValue);
        if(currentValue <= min && currentValue != -99 && currentValue != 'undefined') {
          min = currentValue;
        }
        if(currentValue >= max && currentValue != -99 && currentValue != 'undefined') {
          max = currentValue;
        }
    });
    console.log(min,max);
    return [min,max];  //boomsauce
  }

  function updateProjection(parmValue) {
    // obtained from http://bl.ocks.org/rgdonohue/9280446 and modified slightly
    // not sure we need this at this point
    console.log('setting projection to:', parmValue);

    var opts = options.filter(function(obj) {return obj.name == parmValue;});

    clearInterval(interval);
    update(opts[0]);
  }


  //on initial load get data and store it // we will need to recall this when the underlying data changes  
  getCurrentWorksheet().getUnderlyingDataAsync({
    maxRows: 0,
    ignoreSelection: true,
    includeAllColumns: true,
    ignoreAliases: true
  }).then(onDataLoadOk, onDataLoadError);
  
  //add event listener to the viz
  return getCurrentViz().addEventListener(tableau.TableauEventName.PARAMETER_VALUE_CHANGE, onParmChange);
};


this.appApi = {
  initEditor: initEditor
};